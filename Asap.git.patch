From f853a0a1fec20efd8f849760c5bdb28623ba71e1 Mon Sep 17 00:00:00 2001
From: Hendrik Buschmeier <hbuschme@uni-bielefeld.de>
Date: Thu, 10 Dec 2015 16:56:15 +0100
Subject: [PATCH 1/2] AsapIpaacaIURealizerAdapters now uses BMLA features
 posixStart/EndTime.

---
 AsapIpaacaIURealizerAdapters/ivy.xml               | 22 ++++++++--------
 .../IpaacaToBMLRealizerAdapter.java                | 29 +++++++++-------------
 2 files changed, 23 insertions(+), 28 deletions(-)

diff --git a/AsapIpaacaIURealizerAdapters/ivy.xml b/AsapIpaacaIURealizerAdapters/ivy.xml
index 70c1dad..61dd9dd 100644
--- a/AsapIpaacaIURealizerAdapters/ivy.xml
+++ b/AsapIpaacaIURealizerAdapters/ivy.xml
@@ -1,13 +1,13 @@
 <ivy-module version="2.0">
-   <info organisation="Asap" module="AsapIpaacaIURealizerAdapters"/>
-   <dependencies>
-     <dependency org="Asap"   name="AsapRealizerPort"            rev="latest.${resolve.status}"   />
-     <dependency org="Asap"   name="AsapRealizer"       rev="latest.${resolve.status}"   />
-          <dependency org="Asap"   name="AsapRealizerEmbodiments"       rev="latest.${resolve.status}"   />
-      
-	  <dependency org="saiba"     name="openbmlparser"           rev="latest.${resolve.status}"    />
-	  <dependency org="lombok"   name="lombok"     rev="latest.${resolve.status}"   />
-	  <dependency org="google"   name="guava"     rev="latest.${resolve.status}"   />
-	  <dependency org="ipaaca"  name="ipaaca-java"                  rev="latest.${resolve.status}"  />
-   </dependencies>
+  <info organisation="Asap" module="AsapIpaacaIURealizerAdapters"/>
+  <dependencies>
+    <dependency org="Asap"   name="AsapRealizerPort" rev="latest.${resolve.status}"   />
+    <dependency org="Asap"   name="AsapRealizer" rev="latest.${resolve.status}"   />
+    <dependency org="Asap"   name="AsapRealizerEmbodiments" rev="latest.${resolve.status}"   />
+    <dependency org="Asap"   name="AsapBML" rev="latest.${resolve.status}"    />
+    <dependency org="saiba"   name="openbmlparser" rev="latest.${resolve.status}"    />
+    <dependency org="lombok"  name="lombok" rev="latest.${resolve.status}"   />
+    <dependency org="google"  name="guava" rev="latest.${resolve.status}"   />
+    <dependency org="ipaaca"  name="ipaaca-java" rev="latest.${resolve.status}"  />
+  </dependencies>
 </ivy-module>
diff --git a/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java b/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java
index 4b5291f..435fcb0 100644
--- a/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java
+++ b/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java
@@ -18,11 +18,11 @@ import java.util.HashMap;
 import java.util.Locale;
 
 import saiba.bml.core.BehaviourBlock;
-import saiba.bml.feedback.BMLBlockPredictionFeedback;
-import saiba.bml.feedback.BMLBlockProgressFeedback;
 import saiba.bml.feedback.BMLFeedback;
-import saiba.bml.feedback.BMLFeedbackParser;
-import saiba.bml.feedback.BMLPredictionFeedback;
+import asap.bml.ext.bmla.feedback.BMLAFeedbackParser;
+import asap.bml.ext.bmla.feedback.BMLABlockPredictionFeedback;
+import asap.bml.ext.bmla.feedback.BMLABlockProgressFeedback;
+import asap.bml.ext.bmla.feedback.BMLAPredictionFeedback;
 import asap.realizerport.BMLFeedbackListener;
 import asap.realizerport.RealizerPort;
 
@@ -36,15 +36,12 @@ import com.google.common.collect.ImmutableSet;
  */
 public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 {
-    static double initTime =  System.currentTimeMillis() / 1000.0;
     static
     {
-        //final double initTime =  System.nanoTime() / 1000000000L;
         Initializer.initializeIpaacaRsb();
     }
     
 
-    //private double initTime;
     private final InputBuffer inBuffer = new InputBuffer("IpaacaToBMLRealizerAdapter", ImmutableSet.of(/*"timesyncRequest",*/ IpaacaBMLConstants.REALIZER_REQUEST_CATEGORY));
     private final OutputBuffer outBuffer = new OutputBuffer("IpaacaToBMLRealizerAdapter");
     private final RealizerPort realizerPort;
@@ -179,17 +176,17 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 			BMLFeedback fb;
 			try
 			{
-				fb = BMLFeedbackParser.parseFeedback(feedback);
+				fb = BMLAFeedbackParser.parseFeedback(feedback);
 			}
 			catch (IOException e)
 			{
 				// shouldn't happen since we parse strings
 				throw new AssertionError(e);
 			}
-			if (fb instanceof BMLBlockProgressFeedback)
+			if (fb instanceof BMLABlockProgressFeedback)
 			{
 				AbstractIU iu_to_update = null;
-				BMLBlockProgressFeedback fbBlock = (BMLBlockProgressFeedback) fb;
+				BMLABlockProgressFeedback fbBlock = (BMLABlockProgressFeedback) fb;
 				if (bmlIdToIuIdMap.containsKey(fbBlock.getBmlId())) {
 					iu_to_update = inBuffer.getIU(bmlIdToIuIdMap.get(fbBlock.getBmlId()));
 					if (fbBlock.getSyncId().equals("end"))
@@ -211,27 +208,25 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 					}
 				}
 			}
-			else if (fb instanceof BMLPredictionFeedback)
+			else if (fb instanceof BMLAPredictionFeedback)
 			{
-				BMLPredictionFeedback pf = (BMLPredictionFeedback) fb;
+				BMLAPredictionFeedback pf = (BMLAPredictionFeedback) fb;
 				// FIXME: no clue how to obtain the correct bml ID here...
 				//String bmlid = pf.getBmlBehaviorPredictions().get(0).getBmlId();
 				//iu_to_update = inBuffer.getIU(bmlIdToIuIdMap.get(bmlid));
 				double latestPredictedEndTime = -1;
 				double earliestPredictedStartTime = 9999999999999999999999999.9;
-				for (BMLBlockPredictionFeedback bbp : pf.getBmlBlockPredictions())
+				for (BMLABlockPredictionFeedback bbp : pf.getBMLABlockPredictions())
 				{
 					if (bmlIdToIuIdMap.containsKey(bbp.getId())) {
 						AbstractIU iu_to_update = inBuffer.getIU(bmlIdToIuIdMap.get(bbp.getId()));            	
 						//System.out.println("id="+id);
-						double start = bbp.getGlobalStart() + initTime;
-						double end = bbp.getGlobalEnd() + initTime;
+						double start = bbp.getPosixStartTime() / 1000.0;
+						double end = bbp.getPosixEndTime() / 1000.0;
 						if (end>latestPredictedEndTime) { latestPredictedEndTime = end; }
 						if (start<earliestPredictedStartTime) { earliestPredictedStartTime = start; }
 						new_payload_items.put(IpaacaBMLConstants.IU_PREDICTED_START_TIME_KEY, Double.valueOf(start).toString()); 
 						new_payload_items.put(IpaacaBMLConstants.IU_PREDICTED_END_TIME_KEY, Double.valueOf(end).toString());
-						double t = System.currentTimeMillis()/1000.0;
-						//System.out.println("SEND TIME: " + String.format(Locale.ENGLISH, "%.3f", t));
 						if (iu_to_update != null) {
 							try{
 								iu_to_update.getPayload().merge(new_payload_items);
-- 
2.2.1


From 23e2cff9d695adbc49985115ec88318309d3fef8 Mon Sep 17 00:00:00 2001
From: Hendrik Buschmeier <hbuschme@uni-bielefeld.de>
Date: Fri, 11 Dec 2015 11:55:15 +0100
Subject: [PATCH 2/2] Cleaned up unused code in AsapIpaacaIURealizerAdapters.

---
 .../IpaacaToBMLRealizerAdapter.java                | 97 ++++------------------
 1 file changed, 17 insertions(+), 80 deletions(-)

diff --git a/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java b/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java
index 435fcb0..58b8581 100644
--- a/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java
+++ b/AsapIpaacaIURealizerAdapters/src/asap/ipaacaiuadapters/IpaacaToBMLRealizerAdapter.java
@@ -29,9 +29,10 @@ import asap.realizerport.RealizerPort;
 import com.google.common.collect.ImmutableSet;
 
 /**
- * New bridge between ipaaca and ASAPrealizer, unifying request and feedback into persistent IUs.
- * Replacement for initial ipaaca adapter by Herwin.
- * Assumes that the connected realizerport is threadsafe (or at least that its performBML function is).
+ * New bridge between ipaaca and ASAPrealizer, unifying request and feedback
+ * into persistent IUs. Replacement for initial ipaaca adapter by Herwin.
+ * Assumes that the connected realizerport is threadsafe (or at least that
+ * its performBML function is).
  * @authors Ramin, Hendrik, Herwin
  */
 public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
@@ -41,9 +42,11 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
         Initializer.initializeIpaacaRsb();
     }
     
-
-    private final InputBuffer inBuffer = new InputBuffer("IpaacaToBMLRealizerAdapter", ImmutableSet.of(/*"timesyncRequest",*/ IpaacaBMLConstants.REALIZER_REQUEST_CATEGORY));
-    private final OutputBuffer outBuffer = new OutputBuffer("IpaacaToBMLRealizerAdapter");
+    private final InputBuffer inBuffer = new InputBuffer(
+    	"IpaacaToBMLRealizerAdapter", 
+    	ImmutableSet.of(IpaacaBMLConstants.REALIZER_REQUEST_CATEGORY));
+    private final OutputBuffer outBuffer = new OutputBuffer(
+    	"IpaacaToBMLRealizerAdapter");
     private final RealizerPort realizerPort;
     private long nextUsedAutoBmlId = 1;
     private HashMap<String, String> bmlIdToIuIdMap;
@@ -70,7 +73,6 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 				synchronized (this) {
 					BehaviourBlock bb = new BehaviourBlock();
 					String requested_bml = iu.getPayload().get(IpaacaBMLConstants.REALIZER_REQUEST_KEY);
-					//System.out.println("requested bml {{{ "+requested_bml+" }}}");
 					bb.readXML(requested_bml);
 					String actualBmlId = bb.getBmlId();
 					if (actualBmlId.equals("AUTO")) {
@@ -91,75 +93,21 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 					items.put(IpaacaBMLConstants.BML_ID_KEY, actualBmlId);
 					items.put(IpaacaBMLConstants.IU_STATUS_KEY, "((RECEIVED))");
 					try{
-						//System.out.println("request status update");
 						iu.getPayload().merge(items);
-						//System.out.println("OK status update");
 					} catch (ipaaca.IUUpdateFailedException ex) {
-						//System.out.println("FAILED status update");
 						//
 					}
 				}
            	}
         }, types, ImmutableSet.of(IpaacaBMLConstants.REALIZER_REQUEST_CATEGORY)));
         
-		/* deactivated, replace later with generic timesync for Java
-		// HACK by Ramin
-		// FIXME: this is a minimal reimplementation of the Component timesync code (slave part) from Python ipaaca.util - not yet ported to Java
-		inBuffer.registerHandler(new IUEventHandler(new HandlerFunctor()
-		{
-			@Override
-			public void handle(AbstractIU iu, IUEventType type, boolean local)
-			{
-				synchronized (this) {
-					String master = iu.getPayload().get("master");
-					String master_t1 = iu.getPayload().get("master_t1");
-					String stage = iu.getPayload().get("stage");
-					
-					if (stage.equals("0")) {
-						LocalIU timingIU = new LocalIU();
-						timingIU.setCategory("timesyncReply");
-						double t1 = System.currentTimeMillis() / 1000.0;
-						//HashMap<String, String> items = new HashMap<String, String>();
-						timingIU.getPayload().put("master", master);
-						timingIU.getPayload().put("master_t1", master_t1);
-						timingIU.getPayload().put("slave", "ASAPRealizer");
-						timingIU.getPayload().put("slave_t1", Double.valueOf(t1).toString());
-						timingIU.getPayload().put("stage", "1");
-						//timingIU.getPayload().putAll(items);
-						outBuffer.add(timingIU);
-					}
-				}
-			}
-		}, types, ImmutableSet.of("timesyncRequest")));
-		outBuffer.registerHandler(new IUEventHandler(new HandlerFunctor()
-		{
-			@Override
-			public void handle(AbstractIU iu, IUEventType type, boolean local)
-			{
-				synchronized (this) {
-					String master = iu.getPayload().get("master");
-					String master_t1 = iu.getPayload().get("master_t1");
-					String stage = iu.getPayload().get("stage");
-					if (stage.equals("2")) {
-						double t2 = System.currentTimeMillis() / 1000.0;
-						HashMap<String, String> items = new HashMap<String, String>();
-						items.put("slave_t2", Double.valueOf(t2).toString());
-						items.put("stage", "3");
-						iu.getPayload().merge(items);
-					} else if (stage.equals("4")) {
-						double latency = Double.parseDouble(iu.getPayload().get("latency"));
-						double offset = Double.parseDouble(iu.getPayload().get("offset"));
-						System.out.println("Master "+master+" determined our timing info: round-trip time: "+latency+"  clock offset: "+offset);
-					}
-				}
-			}
-			}, updated_types, ImmutableSet.of("timesyncReply")));
-		// END hack
-		*/
-        
-        ComponentNotifier notifier = new ComponentNotifier("IpaacaToBMLRealizerAdapter", "bmlrealizer",
-                ImmutableSet.of(IpaacaBMLConstants.REALIZER_FEEDBACK_CATEGORY),ImmutableSet.of(IpaacaBMLConstants.REALIZER_REQUEST_CATEGORY),
-                outBuffer, inBuffer);
+        ComponentNotifier notifier = new ComponentNotifier(
+        		"IpaacaToBMLRealizerAdapter",
+        		"bmlrealizer",
+                ImmutableSet.of(IpaacaBMLConstants.REALIZER_FEEDBACK_CATEGORY),
+                ImmutableSet.of(IpaacaBMLConstants.REALIZER_REQUEST_CATEGORY),
+                outBuffer, 
+                inBuffer);
         notifier.initialize();
     }
 
@@ -168,11 +116,6 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
     {
 		synchronized (this) {
 			HashMap<String, String> new_payload_items = new HashMap<String, String>();    	
-			/*LocalMessageIU feedbackIU = new LocalMessageIU();
-			feedbackIU.setCategory(IpaacaBMLConstants.BML_FEEDBACK_CATEGORY);
-			feedbackIU.getPayload().put(IpaacaBMLConstants.BML_FEEDBACK_KEY, feedback);
-			outBuffer.add(feedbackIU);
-			*/
 			BMLFeedback fb;
 			try
 			{
@@ -214,17 +157,12 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 				// FIXME: no clue how to obtain the correct bml ID here...
 				//String bmlid = pf.getBmlBehaviorPredictions().get(0).getBmlId();
 				//iu_to_update = inBuffer.getIU(bmlIdToIuIdMap.get(bmlid));
-				double latestPredictedEndTime = -1;
-				double earliestPredictedStartTime = 9999999999999999999999999.9;
 				for (BMLABlockPredictionFeedback bbp : pf.getBMLABlockPredictions())
 				{
 					if (bmlIdToIuIdMap.containsKey(bbp.getId())) {
 						AbstractIU iu_to_update = inBuffer.getIU(bmlIdToIuIdMap.get(bbp.getId()));            	
-						//System.out.println("id="+id);
 						double start = bbp.getPosixStartTime() / 1000.0;
 						double end = bbp.getPosixEndTime() / 1000.0;
-						if (end>latestPredictedEndTime) { latestPredictedEndTime = end; }
-						if (start<earliestPredictedStartTime) { earliestPredictedStartTime = start; }
 						new_payload_items.put(IpaacaBMLConstants.IU_PREDICTED_START_TIME_KEY, Double.valueOf(start).toString()); 
 						new_payload_items.put(IpaacaBMLConstants.IU_PREDICTED_END_TIME_KEY, Double.valueOf(end).toString());
 						if (iu_to_update != null) {
@@ -236,10 +174,8 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
 						}
 					} else {
 						// ignore this BML block: it was not added by us
-					
 					}
 				}
-				// TODO: also send a global IU/Message with the latest known end time?
 			}
 		}
 	}
@@ -249,4 +185,5 @@ public class IpaacaToBMLRealizerAdapter implements BMLFeedbackListener
         outBuffer.close();
         inBuffer.close();
     }
+
 }
-- 
2.2.1

